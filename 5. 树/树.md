# 定义

​	树是节点的有限集合。

 

​	相关概念：

​	节点、父节点（双亲）、子节点（孩子）、祖先、子孙、堂兄弟

根节点（非终端节点）、叶子节点（终端节点）、

​	度（子节点个数）、深度、节点深度、树深度

有序树、无序树

 

# 特点

每个节点有若干个或0个子节点；

根节点没有父节点；

每一个非根节点有且只有一个父节点；

每个子节点可以分为多个不相交的子树；

# 分类

## 一般树

### 定义

​	任意一个节点的子节点个数不受限制。

### 存储

​	一般树的存储方式包括：双亲表示法，孩子表示法，孩子兄弟表示法，二叉树表示法。

## 二叉树

​	二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第i层至多有2i-1个结点；深度为k的二叉树至多有2k-1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。

 

​	遍历：前序遍历、中序遍历、后序遍历

### 一般二叉树

### 满二叉树

满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

注：在不增加树的层数的前提下，无法再多添加一个节点的二叉树就是满二叉树。

*一般不使用满二叉树，使用的是完全二叉树*，满二叉树是为了引入完全二叉树。

 

　　满二叉树的性质：

　　1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;

　　2) 叶子数为2h;

　　3) 第k层的结点数是：2k-1;

　　4) 总结点数是：2k-1，且总节点数一定是奇数。

 

​	注：如果只是删除了满二叉树最底层最右边的连续若干个节点，这样形成的二叉树就是完全二叉树。

### 完全二叉树

完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

完全二叉树具有满二叉树的大部分性质（满二叉树属于完全二叉树），仅有最后一层缺失部分结点。可以用数组表示，不需要记录父节点与子节点。

*注：*完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

### 线索二叉树

​	二叉树浪费时间和空间：

1、 存储节点元素的时候，需要存储空指针标志“^”，大量浪费空间；

2、 遍历浪费时间（单向）。

#### *定义*

对二叉树的中序遍历可知，这样可以节省空指针标志“^”，利用“^”记录该节点的前驱后继。

 

​	上述树中序遍历的结果是：HDIBEAFCG

​	注：前序和后序遍历都无法利用空闲的“^”指针，只有中序遍历可以刚好有效地利用“^”实现前驱后继的信息存储（正好空出来两个空闲指针存储前驱后继）。

 

​	上述树经过中序遍历后结果是：FDGBACE

​	这种非完全二叉树，看来似乎无法利用“^”存储前驱后继信息了（对于B,C结点只有一个空余结点使用，即指针无法判断是指针还是线索），为此我们将已经定义好的结构进行“扩容”：

| lchild | ltag | data | rtag | rchild |
| ------ | ---- | ---- | ---- | ------ |
|        |      |      |      |        |

​	ltag：为0时指向该结点的左孩子，为1时指向该结点的前驱

​	rtag：为0时指向该结点的右孩子，为1时指向该结点的后继

#### *操作*

##### *初始化*

typedef char ElemType;

 

/*线索存储标志位

Link(0)：表示指向左右孩子的指针

Thread(1):表示指向前驱后继的线索

*/

typedef enum{Link,Thread}PointerFlag;

 

typedef struct BitThrNode

{

​	char data;

​	struct BitThrNode lchild,rchild;

​	PointerFlag ltag;

​	PointerFlag rtag;

}BitThrNode,*BitThrTree;

 

//全局变量,始终指向刚刚访问的结点

BitThrTree pre;

 

//创建一棵二叉树,约定用户遵照前序遍历的方式输入数据

CreateBitThrTree(BitThrTree *T)

{

​	char c;

​	scanf("%c",&c);

​	if('' == c)

​	{

​		*T = NULL;

​	}

​	else

​	{

​		*T = (BitThrNode *)malloc(sizeof(BitThrNode));

​		(*T)->data = c;

​		(*T)->ltag = Link;

​		(*T)->rtag = Link;

​		

​		CreateBitThrTree(&(*T)->lchild);

​		CreateBitThrTree(&(*T)->rchild);

​	}

}

##### *查询*

##### *插入*

##### *删除*

### 二叉查找/搜索/排序树

#### *定义*

二叉查找树又称为是二叉排序树（Binary Sort Tree，简写BST）或二叉搜索树。

树的每个节点都包含了健值 key、数据值 data、左子节点指针、右子节点指针。其中健值 key 是最核心的部分，它的值决定了树的组织形状；数据值 data 是该节点对应的数据，有些场景可以忽略。

#### *分类*

##### *T**reap树*

#### *特点*

二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

　　1) 若左子树不空，则左子树上所有结点的key值均小于它的根结点的key值；

　　2) 若右子树不空，则右子树上所有结点的key值均大于或等于它的根结点key的值；

　　3) 左、右子树也分别为二叉排序树；

\4) 没有键值相等的节点（即等于的情况只能出现在左子树或右子树中的某一侧）。

 

由于二叉查找树的中序遍历时从小到大的，故又名二叉排序树（Binary Sort Tree）。

#### *性质*

二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。

#### *操作*

##### *初始化*

//二叉树的二叉链表结点结构定义

typedef struct BitNode

{

​	int data;

​	struct BitNode *lchild, *rchild;

}BiTNode,*BiTree;

 

##### *查询*

​	查找数值value是否在二叉查找树中出现：

1、 如果value等于当前查看node的节点值：返回true

2、 如果value节点值小于当前node节点值：

2.1如果当前节点有左子树，继续在左子树中查找该值；

2.2否则，返回false

3、 否则（value节点值大于当前node节点值）：

3.1如果当前节点有右子树，继续在右子树中查找该值；

3.2否则，返回false

​	代码：

 

/*

递归查找儿二叉排序树T中是否存在key

指针f指向T的双亲，其初始值调用值为NULL

若查找成功，则指针p指向该数据元素结点，并返回TRUE

否则指针p指向查找路径上访问的最后一个结点，并返回FALSE

*/

bool SearchBST(BiTree T, int key, BiTree f, BiTree *p)

{

​	if(!T)	//查找不成功

​	{

​		*p = f;

​		return true;

​	}

​	else if(key == T->data)	//查找成功

​	{

​		*p = T;

​		return true;

​	}

​	else if(key<T->data)

​	{

​		return SearchBST(T->lchild, key, T, p);	//在左子树继续查找

​	}

​	else

​	{

​		return SearchBST(T->rchild, key, T, p);	//在右子树继续查找

​	}

}

测试：

 

##### *插入*

　　二叉查找树的高度决定了二叉查找树的查找效率。对于查找操作而言，二叉查找树和有序数组基本等同，但是为什么还需要二叉查找树而不直接用有序数组替换呢？这是因为二者的插入效率不同，对于有序数组，需要移动大量元素，时间复杂度为O(n)。

将某结点（insert_node）插入至以node为根节点二叉查找树中：

 

1、若当前的二叉查找树为空，则插入的元素为根节点;

2、若insert_node插入的元素值小于当前node节点值：

2.1如果node有左子树，则递归将该节点插入至左子树为根二叉排序树中；

2.2否则，将node->left赋值为该节点地址

3、否则（大于等于情况）：

3.1如果node有右子树，则递归将该节点插入至右子树为根二叉排序树中

3.2否则，将node->right赋值为该节点地址

代码：

 

//二叉树的二叉链表结点结构定义

typedef struct BitNode

{

​	int data;

​	struct BitNode *lchild, *rchild;

}BiTNode,*BiTree;

 

/*

当二叉排序树T中不存在关键字等于key的数据元素时,

插入key并返回TRUE，否则返回FALSE

*/

bool InsertBST(BiTree *T, int key)

{

​	BiTree p,s;

​	if( !SearchBST(*T,key, NULL, &p))

​	{

​		s = (BiTree)malloc(sizeof(BiTNode));

​		s->data = key;

​		s->lchild = s->rchild = NULL;

​		

​		if(!p)	//查找不到key

​		{

​			*T = s;	//插入s为新的根节点

​		}

​		else if(key<p->data)

​		{

​			p->lchild = s;	//插入s为左孩子

​		}

​		else

​		{

​			p->rchild = s;	//插入s为右子树

​		}

​		return true;

​	}

​	else

​	{

​		return false;

​	}

}

测试：

 

##### *删除*

　　二叉查找树的删除，分三种情况进行处理：

　　1) p为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点），如图a;

　　2) p为单支节点（即只有左子树或右子树）。让p的子树与p的父亲节点相连，删除p即可（注意分是根节点和不是根节点），如图b;

　　3) p的左子树和右子树均不空。找到p的后继y，因为y一定没有左子树，所以可以删除y，并让y的父亲节点成为y的右子树的父亲节点，并用y的值代替p的值；或者方法二是找到p的前驱x，x一定没有右子树，所以可以删除x，并让x的父亲节点成为y的左子树的父亲节点。如图c。

 

 

 

#### *复杂度*

二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

#### *应用*

##### *编码/解码*

​	题目：给定一个二叉查找树，实现对该二叉查找树编码与解码功能。编码即将该二叉查找树转为字符串，解码即将字符串转为二叉查找树。不限制使用任何编码算法，只需保证当对二叉查找树调用编码功能后可再调用解码功能将其复原。

 

​	注：Leetcode 449

​	分析：

​	对二叉查找树进行前序遍历，将遍历得到的结果按顺序重新构造为一颗新的二叉查找树，新的二叉查找树与原二叉查找树完全一样。

 

​	算法思路（编码）：

​	二叉查找树编码为字符串：将二叉查找树前序遍历，遍历时将整型的数据转为字符串，并将这些字符串数据进行连接，连接时使用特殊字符分割。

 

​	算法思路（解码）：

​	将字符串解码为二叉查找树：将字符串按照编码时的分隔符“#”，将各个数字逐个拆分出来，将第一个数字构建为二叉查找树的根节点，后面各个数字构建出的节点按照解析时的顺序插入根节点中，返回根节点，即完成了编码工作。

 

​	

*整型转换为字符串（编码）：*

利用对整数10取余，可以逐个循环的将一个整数从最低位到最高位拆分出来，在这个过程中每取出一个最低位，就将该数字除以10。每拆分出一个字符，就将这个字符添加到string中，直到该数字为0结束。最后将string进行反转，就完成了整数转字符串。

 

​	字符串转化为整数（解码）：

 

​	代码：

​	编码：

 

​	解码：

 

​	测试：

 

##### *逆序数*

​	题目：已知数组nums，求新数组count，count[i]代表了在nums[i]右侧且比nums[i]小的元素个数。

 

​	注：Leetcode 315

分析：

已知数组nums=[5,-7,9,1,3,5,-2,1]，它的逆序数数组count=[5,0,5,1,2,2,0,0]；数组count[i]，为nums[i+1]、nums[i+2]、…、nums[size()-1]中有多少个比nums[i+1]小的数；

或者将数组逆置[1,-2,5,3,1,9,-7,5]，数组count[i]为nums[0]、nums[1]、…、nums[i-1]中有多少个比nums[i]小的数：

1，[]中比它小的数个数为0；

-2，[1]中比它小的数个数为0；

5，[1,-2]中比它小的数个数为2；

3，[1,-2,5]中比它小的数个数为2；

1，[1,-2,5,3]中比它小的数个数为1；

9，[1,-2,5,3,1]中比它小的数个数为5,；

-7，[1,-2,5,3,1,9]中比它小的数个数为0；

5，[1,-2,5,3,1,9,-7]中比它小的数个数为5；

思考：将元素按照原数组逆置后的顺序插入到二叉查找树中，如何在元素插入时，计算已有多少个元素比当前插入元素小？

记录左子树数量二叉查找树：

 

代码：

 

测试：

 

### 平衡二叉树

我们知道，对于一般的二叉搜索树（Binary Search Tree），其期望高度（即为一棵平衡树时）为log2n，其各操作的时间复杂度O(log2n)同时也由此而决定。但是，在某些极端的情况下（如在插入的序列是有序的时），二叉搜索树将退化成近似链或链，此时，其操作的时间复杂度将退化成线性的，即O(n)。

我们可以通过随机化建立二叉搜索树来尽量的避免这种情况，但是在进行了多次的操作之后，由于在删除时，我们总是选择将待删除节点的后继代替它本身，这样就会造成总是右边的节点数目减少，以至于树向左偏沉。这同时也会造成树的平衡性受到破坏，提高它的操作的时间复杂度。于是就有了我们下边介绍的平衡二叉树。

#### *定义*

平衡二叉树（Balanced Binary Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

注：我们将二叉树上的结点上的左子树的深度的值减去右子树的深度的值称为平衡因子BF（Balance Factor），平衡二叉树就是一棵二叉树上所有结点的平衡因子的绝对值小于等于1的树。

平衡二叉树的常用算法有红黑树、AVL树等。

在平衡二叉搜索树中，我们可以看到，其高度一般都良好地维持在O(log2n)，大大降低了操作的时间复杂度。

 

　　最小二叉平衡树的节点的公式如下：

　　F(n)=F(n-1)+F(n-2)+1

　　这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。

#### *分类*

##### *AVL树*

###### *定义*

AVL树是最先发明的自平衡二叉查找树。AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 "An algorithm for the organization of information" 中发表了它。

在AVL中任何节点的两个儿子子树的高度最大差别为1，所以它也被称为高度平衡树，n个结点的AVL树最大深度约1.44log2n。

###### *性质*

查找、插入和删除在平均和最坏情况下都是O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。*这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)**。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，**时间上稳定了很多**。*

###### *自平衡*

　　*AVL树的自平衡操作——旋转：*

　　AVL树最关键的也是最难的一步操作就是*旋转*。旋转主要是为了实现AVL树在实施了插入和删除操作以后，树重新回到平衡的方法。下面我们重点研究一下AVL树的旋转。

　　对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况：

 

　　1) 6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。

　　2) 6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。

　　3) 2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。

　　4) 2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。

　　从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。

*单旋转*

　　单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。

 

为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。

　　这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。

*双旋转*

对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。

 

 为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树。

 

##### *红黑树*

###### *定义*

红黑树的定义：红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现*关联数组*。它是在1972年由鲁道夫·贝尔发明的，称之为"对称二叉B树"，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。

 

红黑树和AVL树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。

###### *性质*

　　红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

　　性质1. 节点是红色或黑色。

　　性质2. 根是黑色。

　　性质3. 所有叶子都是黑色（叶子是NIL节点）。

　　性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)

性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

注：一半以上的节点都是黑节点。

　　下面是一个具体的红黑树的图例：

 

　　这些约束确保了红黑树的关键特性: *从根到叶子的最长的可能路径不多于最短的可能路径的两倍长*。结果是这个*树大致上是平衡的*。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。

　　要知道为什么这些性质确保了这个结果，注意到性质4导致了路径不能有两个毗连的红色节点就足够了。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。

###### *自平衡*

　　红黑树的自平衡操作：

　　因为每一个红黑树也是一个特化的二叉查找树，因此红黑树上的只读操作与普通二叉查找树上的只读操作相同。然而，在红黑树上进行插入操作和删除操作会导致不再符合红黑树的性质。恢复红黑树的性质需要少量(O(logn))的颜色变更(实际是非常快速的)和不超过三次树旋转(对于插入操作是两次)。虽然插入和删除很复杂，但操作时间仍可以保持为O(logn)次。

我们首先以二叉查找树的方法增加节点并标记它为红色。如果设为黑色，就会导致根到叶子的路径上有一条路上，多一个额外的黑节点，这个是很难调整的（违背性质5）。但是设为红色节点后，可能会导致出现两个连续红色节点的冲突，那么可以通过颜色调换（color flips）和树旋转来调整。下面要进行什么操作取决于其他临近节点的颜色。同人类的家族树中一样，我们将使用术语叔父节点来指一个节点的父节点的兄弟节点。注意:

性质1和性质3总是保持着。

性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。

性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。

 

*插入操作*

　　假设，将要插入的节点标为N，N的父节点标为P，N的祖父节点标为G，N的叔父节点标为U。在图中展示的任何颜色要么是由它所处情形这些所作的假定，要么是假定所暗含的。

　　*情形1:* 该树为空树，直接插入根结点的位置，违反性质1，把节点颜色有红改为黑即可。

　　*情形2:* 插入节点N的父节点P为黑色，不违反任何性质，无需做任何修改。在这种情形下，树仍是有效的。性质5也未受到威胁，尽管新节点N有两个黑色叶子子节点；但由于新节点N是红色，通过它的每个子节点的路径就都有同通过它所取代的黑色的叶子的路径同样数目的黑色节点，所以依然满足这个性质。

　　注： 情形1很简单，情形2中P为黑色，一切安然无事，但P为红就不一样了，下边是P为红的各种情况，也是真正难懂的地方。

　　*情形3:* 如果父节点P和叔父节点U二者都是红色，(此时新插入节点N做为P的左子节点或右子节点都属于情形3,这里右图仅显示N做为P左子的情形)则我们可以将它们两个重绘为黑色并重绘祖父节点G为红色(用来保持性质4)。现在我们的新节点N有了一个黑色的父节点P。因为通过父节点P或叔父节点U的任何路径都必定通过祖父节点G，在这些路径上的黑节点数目没有改变。但是，红色的祖父节点G的父节点也有可能是红色的，这就违反了性质4。为了解决这个问题，我们在祖父节点G上递归地进行上述情形的整个过程（把G当成是新加入的节点进行各种情形的检查）。比如，G为根节点，那我们就直接将G变为黑色（情形1）；如果G不是根节点，而它的父节点为黑色，那符合所有的性质，直接插入即可（情形2）；如果G不是根节点，而它的父节点为红色，则递归上述过程（情形3）。

 

　　*情形4:* 父节点P是红色而叔父节点U是黑色或缺少，新节点N是其父节点的左子节点，而父节点P又是其父节点G的左子节点。在这种情形下，我们进行针对祖父节点G的一次右旋转; 在旋转产生的树中，以前的父节点P现在是新节点N和以前的祖父节点G的父节点。我们知道以前的祖父节点G是黑色，否则父节点P就不可能是红色(如果P和G都是红色就违反了性质4，所以G必须是黑色)。我们切换以前的父节点P和祖父节点G的颜色，结果的树满足性质4。性质5也仍然保持满足，因为通过这三个节点中任何一个的所有路径以前都通过祖父节点G，现在它们都通过以前的父节点P。在各自的情形下，这都是三个节点中唯一的黑色节点。

 

　　*情形5:* 父节点P是红色而叔父节点U是黑色或缺少，并且新节点N是其父节点P的右子节点而父节点P又是其父节点的左子节点。在这种情形下，我们进行一次左旋转调换新节点和其父节点的角色; 接着，我们按情形4处理以前的父节点P以解决仍然失效的性质4。注意这个改变会导致某些路径通过它们以前不通过的新节点N（比如图中1号叶子节点）或不通过节点P（比如图中3号叶子节点），但由于这两个节点都是红色的，所以性质5仍有效。

 

注: 插入实际上是原地算法，因为上述所有调用都使用了尾部递归。

*删除操作*

　　如果需要删除的节点有两个儿子，那么问题可以被转化成删除另一个只有一个儿子的节点的问题。对于二叉查找树，在删除带有两个非叶子儿子的节点的时候，我们找到要么在它的左子树中的最大元素、要么在它的右子树中的最小元素，并把它的值转移到要删除的节点中。我们接着删除我们从中复制出值的那个节点，它必定有少于两个非叶子的儿子。因为只是复制了一个值，不违反任何性质，这就把问题简化为如何删除最多有一个儿子的节点的问题。它不关心这个节点是最初要删除的节点还是我们从中复制出值的那个节点。

　　我们只需要讨论删除只有一个儿子的节点(如果它两个儿子都为空，即均为叶子，我们任意将其中一个看作它的儿子)。如果我们删除一个红色节点（此时该节点的儿子将都为叶子节点），它的父亲和儿子一定是黑色的。所以我们可以简单的用它的黑色儿子替换它，并不会破坏性质3和性质4。通过被删除节点的所有路径只是少了一个红色节点，这样可以继续保证性质5。另一种简单情况是在被删除节点是黑色而它的儿子是红色的时候。如果只是去除这个黑色节点，用它的红色儿子顶替上来的话，会破坏性质5，但是如果我们重绘它的儿子为黑色，则曾经通过它的所有路径将通过它的黑色儿子，这样可以继续保持性质5。

　　需要进一步讨论的是在要删除的节点和它的儿子二者都是黑色的时候，这是一种复杂的情况。我们首先把要删除的节点替换为它的儿子。出于方便，称呼这个儿子为N(在新的位置上)，称呼它的兄弟(它父亲的另一个儿子)为S。在下面的示意图中，我们还是使用P称呼N的父亲，SL称呼S的左儿子，SR称呼S的右儿子。

　　如果N和它初始的父亲是黑色，则删除它的父亲导致通过N的路径都比不通过它的路径少了一个黑色节点。因为这违反了性质5，树需要被重新平衡。有几种情形需要考虑:

　　*情形1:* N是新的根。在这种情形下，我们就做完了。我们从所有路径去除了一个黑色节点，而新根是黑色的，所以性质都保持着。

　　注意: 在情形2、5和6下，我们假定N是它父亲的左儿子。如果它是右儿子，则在这些情形下的左和右应当对调。

　　*情形2:* S是红色。在这种情形下我们在N的父亲上做左旋转，把红色兄弟转换成N的祖父，我们接着对调N的父亲和祖父的颜色。完成这两个操作后，尽管所有路径上黑色节点的数目没有改变，但现在N有了一个黑色的兄弟和一个红色的父亲（它的新兄弟是黑色因为它是红色S的一个儿子），所以我们可以接下去按情形4、情形5或情形6来处理。

 

　　*情形3:* N的父亲、S和S的儿子都是黑色的。在这种情形下，我们简单的重绘S为红色。结果是通过S的所有路径，它们就是以前不通过N的那些路径，都少了一个黑色节点。因为删除N的初始的父亲使通过N的所有路径少了一个黑色节点，这使事情都平衡了起来。但是，通过P的所有路径现在比不通过P的路径少了一个黑色节点，所以仍然违反性质5。要修正这个问题，我们要从情形1开始，在P上做重新平衡处理。

 

　　*情形4:* S和S的儿子都是黑色，但是N的父亲是红色。在这种情形下，我们简单的交换N的兄弟和父亲的颜色。这不影响不通过N的路径的黑色节点的数目，但是它在通过N的路径上对黑色节点数目增加了一，添补了在这些路径上删除的黑色节点。

 

　　*情形5:* S是黑色，S的左儿子是红色，S的右儿子是黑色，而N是它父亲的左儿子。在这种情形下我们在S上做右旋转，这样S的左儿子成为S的父亲和N的新兄弟。我们接着交换S和它的新父亲的颜色。所有路径仍有同样数目的黑色节点，但是现在N有了一个黑色兄弟，他的右儿子是红色的，所以我们进入了情形6。N和它的父亲都不受这个变换的影响。

 

　　*情形6:* S是黑色，S的右儿子是红色，而N是它父亲的左儿子。在这种情形下我们在N的父亲上做左旋转，这样S成为N的父亲（P）和S的右儿子的父亲。我们接着交换N的父亲和S的颜色，并使S的右儿子为黑色。子树在它的根上的仍是同样的颜色，所以性质3没有被违反。但是，N现在增加了一个黑色祖先: 要么N的父亲变成黑色，要么它是黑色而S被增加为一个黑色祖父。所以，通过N的路径都增加了一个黑色节点。

此时，如果一个路径不通过N，则有两种可能性:

1、 它通过N的新兄弟。那么它以前和现在都必定通过S和N的父亲，而它们只是交换了颜色。所以路径保持了同样数目的黑色节点。

2、 它通过N的新叔父，S的右儿子。那么它以前通过S、S的父亲和S的右儿子，但是现在只通过S，它被假定为它以前的父亲的颜色，和S的右儿子，它被从红色改变为黑色。合成效果是这个路径通过了同样数目的黑色节点。

　　在任何情况下，在这些路径上的黑色节点数目都没有改变。所以我们恢复了性质4。在示意图中的白色节点可以是红色或黑色，但是在变换前后都必须指定相同的颜色。

 

##### *线段树*

###### *定义*

​	线段树是一种平衡二叉搜索树（完全二叉树），它将一个线段区间划分成一些单元区间。对于线段树中的每一个非叶子节点[a,b]，它的左儿子表示的区间为[a,(a+b)/2]，右儿子表示的区间为[(a+b)/2+1,b]，最后的叶子节点数目为N，与数组下标对应。

 

​	线段树操作一般包括：建立、查询、插入、更新，建立规模为N的时间复杂度是O(NlogN)，其他操作时间复杂度为O(logN)。

###### *操作*

*保存*

*构造*

 

​	代码：

 

*遍历*

 

*求和*

 

​	代码：

 

*更新*

 

​	代码：

 

​	测试：

 

## 多路查找树

​	多路查找树的特点是每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。

​	B树、2-3树等都是多路查找树。

 

​	因为多路查找树是一种查找树，所以元素之间存在某种特定的排序关系，它在降低磁盘IO方面起到了很好的作用。

​	注：二叉树一个结点只能有2个孩子，当元素比较多的时候，就会导致树的高度非常大，由于访问磁盘的时间要比内存慢得多，所以对整个查找树执行查找会多次访问磁盘。

### 2-3**树**

B-树即是平衡树，平衡树是为了解决不平衡树查询效率问题，常见的二叉平衡树有AVL树，它虽然提高了查询效率，但是插入操作效率不高，因为它需要再每次插入节点后维护树的平衡，而为了解决查询效率同时有兼顾插入效率，于是提出了2-3树。

#### *定义*

 

2-3树，是最简单的B-树，其中2、3主要体现在每个非叶子节点都有2个或3个子节点。

一个结点拥有两个孩子和一个元素我们称之为2结点，它跟二叉排序树类似，左子树包含的元素小于结点的元素，右子树包含的元素大于结点的元素。不过与二叉排序树不同的是，这个2结点要么没有孩子，要么就应该有两个孩子，而不能只有一个孩子。

注：要么没有孩子，要么有2、3个孩子。

#### *特点*

2-3树是一棵平衡树，但不是二叉平衡树。

对于高度相同的2-3树和二叉树，2-3树的节点数要大于满二叉树，因为有些节点可能有三个子节点。

2-3树可以是一棵空树。

对于2节点来说，该节点保存了一个key及对应的value，除此之外还保存了指向左右两边的子节点，子节点也是一个2-3节点，左子节点所有值小于key，右子节点所有值大于key。

对于3节点来说，该节点保存了两个key及对应的value，除此之外还保存了指向左中右三个方向的子节点，子节点也是一个2-3节点，左子节点的所有值小于两个key中较小的那个，中节点的所有值在两个key值之间，右子节点大于两个key中较大的那个。

对2-3树进行中序遍历能得到一个排好序的序列。

#### *查找*

​	中序遍历可以得到一个从小到大的结果，然后执行查找。

#### *插入*

​	2-3树的插入需要考虑树的高度，即所有的叶子节点必须都在同一个高度。

 

​	插入数据3：

 

​	插入数据5：

 

​	插入数据11：

 

 

#### *删除*

 

​	删除数字1：

 

​	继续删除数字4：

 

​	继续删除数字10：

 

​	继续删除数字12：

 

​	继续删除数字8：

 

### 2-**3-4树**

​	2-3-4树是红黑树的基础。

#### *定义*

 

#### *查找*

 

#### *插入*

 

 

 

#### *分裂结点*

 

### B**-树**

### B树

#### *定义*

B树也是一种用于查找的平衡树，但是它不是二叉树。

B树即平衡查找树，一般理解为平衡多路查找树，也称为B-树、B_树。是一种自平衡树状数据结构，能对存储的数据进行O(log n)的时间复杂度进行查找、插入和删除。B树一般较多用在存储系统上，比如数据库或文件系统。

 

B树的定义：B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。

 

​	注：上述B树中间结点和叶子节点存储数据，为了加快查找的速度，可以采用B树的变种：

 

​	注：中间结点只存储索引，数据存储在叶子节点。叶子节点可以直接存储数据，也可以存储数据的链表地址。

#### *特点*

　　B树作为一种多路搜索树（并不是二叉的）：

　　1) 定义任意非叶子结点最多只有M个儿子；且M>2（即如果根节点不是叶子节点，则其至少有两棵子树）；

　　2) 根结点的儿子数为[2, M]；

　　3) 除根结点以外的非叶子结点的儿子数为[M/2, M]；

　　4) 每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）

　　5) 非叶子结点的关键字个数=指向儿子的指针个数-1；

　　6) 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；

　　7) 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；

　　8) 所有叶子结点位于同一层；

#### *插入*

#### *查找*

　　在B树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。

 

### B+树

B+树是B树的一种变体，也属于平衡多路查找树，大体结构与B树相同，包含根节点、内部节点和叶子节点。多用于数据库和操作系统的文件系统中，由于B+树内部节点不保存数据，所以能在内存中存放更多索引，增加缓存命中率。另外因为叶子节点相连遍历操作很方便，而且数据也具有顺序性，便于区间查找。

#### *特点*

​	B+树是B树的变体，也是一种多路搜索树：

　　1) 其定义基本与B-树相同，除了：

　　2) 非叶子结点的子树指针与关键字个数相同；

　　3) 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；

　　4) 为所有叶子结点增加一个链指针；

　　5) 所有关键字都在叶子结点出现；

 

B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

 

　　B+的性质：

　　1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；

　　2.不可能在非叶子结点命中；

　　3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；

4.更适合文件索引系统。

#### *查询*

#### *插入*

#### *删除*

### B***树**

​	B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。

 

　　B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）；

 

　　B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；

 

　　B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；

 

　　所以，B*树分配新结点的概率比B+树要低，空间使用率更高。

## 森林

### 定义

​	N个互不相交的树的集合。

### 存储

​	先把森林转化成二叉树，再存储二叉树。

### 转换

#### *树-**>**二叉树*

#### *森林->二叉树*

#### *二叉树-**>**树/森林*

## Trie树

### 概述

Trie树称为字典树或前缀树，又称单词查找树，是一种有序的、用于统计、排序和存储字符串的数据结构，它与二叉查找树不同，关键字不是直接保存在节点中，而是由节点在树中的位置决定的。

Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。

注：文本词频统计中，如果数据量不大可以使用Trie树，数据量很大的时候使用大数据的MapReduce思想。

 

一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。

 

优点：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　

缺点：在存储比较稀疏的数据时占用空间没有优势，只有在存储类似“字典”这种大量的数据时才会有空间和查询的优势。

### 性质

　　Tire树的三个基本性质：

　　1) 根节点不包含字符，除根节点外每一个节点都只包含一个字符；

　　2) 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；

\3) 每个节点的所有子节点包含的字符都不相同。

### 操作

#### *表示*

Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。

为什么说非典型呢？因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，比如一般的多叉树的结点是这样的：

struct TreeNode {

  VALUETYPE value;   //结点值（数据域）

  TreeNode* children[NUM];   //指向孩子结点

};

而 Trie 的结点是这样的(假设只包含'a'~'z'中的字符)：

struct TrieNode {

  bool isEnd; //该结点是否是一个串的结束（Trie树没有数据域！）

  TrieNode* next[26]; //字母映射表

};

要想学会 Trie 就得先明白它的结点设计。我们可以看到TrieNode结点中并没有直接保存字符值的数据成员，那它是怎么保存字符的呢？

这时字母映射表next 的妙用就体现了，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：

for (int i = 0; i < 26; i++) {

  char ch = 'a' + i;

  if (parentNode->next[i] == NULL) {

​    说明父结点的后一个字母不可为 ch

  } else {

​    说明父结点的后一个字母可以是 ch

  }

}



Trie中一般都含有大量的空链接，因此在绘制一棵单词查找树时一般会忽略空链接，同时为了方便理解我们可以画成这样：



 

 

​	注：子节点的个数定义为字母个数26个即可，标记位is_end表示该节点是否为对应字符串的最后一个字母，比如上述的根节点存储b，对于字符串b而言该节点是结束的节点，而对于bcd则不是，bcd结束的字母是d节点。

#### *构造*

 

​	注：根节点对应的元素就是需要存储的字符串的第一个字母，这里分别是a,b,e。

#### *前序遍历*

 

​	注：Trie树的遍历其实就是依次遍历每一层，每一层遍历26个字母，如果对应字母位置存在元素，则可以计算出这个地方存储的元素。

#### *获取单词*

​	查找单词，其实就是一种前序遍历。

​	1、深度搜索Trie树，对于正在搜索的节点node：

​	2、遍历该节点的26个孩子指针childi，如果指针不空：

​	2.1将该child[i]对应的字符(i+’a’)，push进入栈中，

​	2.2如果该孩子指针标记的is_end为真（说明这个位置是一个单词）：

​		2.2.1从栈底到栈顶对栈进行遍历，生成字符串，将它保存到结果数组中

​	2.3深度搜索child[i]

​	2.4弹出栈顶字符

 

​	分析：

 

 

​	代码：

 

#### *插入单词*

​	Trie树的整体功能：

 

​	分析：

 

​	代码：

 

#### *搜索单词*

​	分析：

 

​	代码：

 

#### *前缀查询*

 

​	测试：

 

### 应用

　　Tire树的应用：

　　1) 串的快速检索

　　给出N个单词组成的熟词表，以及一篇全用小写英文书写的文章，请你按最早出现的顺序写出所有不在熟词表中的生词。

在这道题中，我们可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。

　　2) “串”排序

　　给定N个互不相同的仅由一个单词构成的英文名，让你将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。

　　3) 最长公共前缀

对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为求公共祖先的问题。

#### *实现trie树*

​	题目：实现一个trie树，包括insert（插入单词）、search（搜索单词）、startWith（检查是否包含前缀）。输入的字符串只包含小写字符（a-z）。

 

​	注：Leetcode 208

​	分析：

​	代码：

​	测试：

 

#### *词典中最长的单词*

#### *添加与查找单词*

## Radix树

​	Radix树，即基数树，也称压缩前缀树，是一种提供key-value存储查找的数据结构。与Trie不同的是，它对Trie树进行了空间优化，只有一个子节点的中间节点将被压缩。同样的，Radix树的插入、查询、删除操作的时间复杂度都为O(k)。

### 特点

一般由根节点、中间节点和叶子节点组成。

每个节点可以包含一个或多个字符。

树的叶子结点数即是数据条目数。

从根节点到某一节点经过路径的字符连起来即为该节点对应的字符串。

每个节点的所有子节点字符串都不相同。

### 插入

### 查询

## LSM

# 存储

​	要存储树，简单的顺序存储结构和链式存储结构是不可以的。不过如果充分利用它们各自的特点，完全可以间接地实现。

​	一般树的存储方式包括：

## 双亲表示法

​	双亲表示反，就是以双亲作为索引的关键词的一种存储方式。

​	注：求父节点方便。

### 原理

 

 

​	这样的存储结构，我们可以根据某结点的parent指针找到它的双亲结点，所用的复杂度是O(1)，索引到parent的值为-1时，表示找到了树节点的根。如果我们要知道某结点的还是是什么，则需要遍历整个树结构。

​	针对上述情况，可以做如下的改进：

 

### 代码

typedef struct PTNode

{

​	ElemType data;	//结点数据

​	int parent;	//双亲位置

}PTNode;

 

typedef struct

{

​	PTNode nodes[MAX_TREE_SIZE];

​	int r;	//根的位置

​	int n;	//结点数目

}PTree;

 

## 孩子表示法

### 原理

​	注：求子节点方便。

### 代码

#define MAX_TREE_SIZE 100

 

typedef int ElemType;

//孩子结点

typedef struct CTNode

{

​	int child;	//孩子结点的下表

​	struct CTNode *next;	//指向下一个孩子结点的指针

}*ChildPtr;

 

//表头结构

typedef struct

{

​	ElemType data;	//存放在树中的结点的数据

​	int parent;	//存放双亲的下标

​	ChildPtr firstchild;	//指向第一个孩子的指针

}CTBox;

 

//树结构

typedef struct

{

​	CTBox nodes[MAX_TREE_SIZE];	//结点数组

​	int r,n;

}

## 孩子双亲表示法

### 原理

​	注：求父节点和子节点都很方便。

### 代码

## 二叉树表示法

​	把一个普通树转化成二叉树来存储。

​	

### 原理

​	具体转换方法：

​	设法保证任意一个节点的左指针域指向它的第一个孩子，右指针域指向它的下一个兄弟。

​	只要能满足此条件，就可以把一个普通树转化为二叉树。一个普通树转化成的二叉树一定没有右子树。

### 代码

# 实现

## 数组

## 链表

# 二叉树

## 存储

### 顺序存储

​	使用数组存储二叉树。

​	优点：查找某个节点的父节点和子节点（也包括判断有没有子节点）速度非常快。（不需要遍历树，找到节点后前后即为父子节点）

​	缺点：耗用内存空间过大。

​	注：必须将树转化为完全二叉树的形式（不存在的节点占用空位置）才能使用顺序存储（如果只存储有效的点，无法获取树的真实结构）。

### 链式存储/二叉链表

​	为了克服数组存储耗用内存过大的情况，采用链式存储较为节约空间（但是，不存在子节点的空指针域也存在一定的空间浪费）。

## 定义

typedef struct Bin_Tree BinTree;

struct Bin_Tree

{

​	int value;

​	BinTree* right;

​	BinTree* left;

};

或者：

struct Bin_Tree

{

​	int value;

​	BinTree* right;

​	BinTree* left;

​	Node(int value){

​		this.value = data;

​	}

};

 

## 初始化

/*

构造二叉搜索树 

*/

BinTree* InsertNode(BinTree* root,int value)

{

​	BinTree* newnode = new BinTree;

​	newnode->value = value;

​	newnode->right = NULL;

​	newnode->left = NULL;

​	//创建完一个新的节点，需要将此节点插入到合适的位置

​	if(root == NULL)

​	{

​		root = newnode;

​	} 

​	else

​	{

​		//找合适的位置

​		BinTree* parent = root;

​		while(parent != NULL)

​		{

​			if(parent->value < value)

​			{

​				if(parent->right == NULL)

​					break;

​				else

​					parent = parent->right;

​			}

​			else

​			{

​				if(parent->left == NULL)

​					break;

​				else

​					parent = parent->left;

​			}

​		} 

​		if(parent->value < value)

​			parent->right = newnode;

​		else

​			parent->left = newnode;

​	}

​	return root;

} 

## 遍历

#include <iostream>

#include <stack>

#include <vector>

#include <deque>

using namespace std;

 

/*

二叉搜索树的创建

二叉树的递归遍历

二叉树的非递归遍历 

*/

typedef struct Bin_Tree BinTree;

struct Bin_Tree

{

​	int value;

​	BinTree* right;

​	BinTree* left;

};

 

/*

构造二叉搜索树 

*/

BinTree* InsertNode(BinTree* root,int value)

{

​	BinTree* newnode = new BinTree;

​	newnode->value = value;

​	newnode->right = NULL;

​	newnode->left = NULL;

​	//创建完一个新的节点，需要将此节点插入到合适的位置

​	if(root == NULL)

​	{

​		root = newnode;

​	} 

​	else

​	{

​		//找合适的位置

​		BinTree* parent = root;

​		while(parent != NULL)

​		{

​			if(parent->value < value)

​			{

​				if(parent->right == NULL)

​					break;

​				else

​					parent = parent->right;

​			}

​			else

​			{

​				if(parent->left == NULL)

​					break;

​				else

​					parent = parent->left;

​			}

​		} 

​		if(parent->value < value)

​			parent->right = newnode;

​		else

​			parent->left = newnode;

​	}

​	return root;

} 

### 前/先序遍历

​	先序遍历：先访问根节点à再先序访问左子树（即处理完所有左子树）à再先序访问右子树

#### *递归*

/*

递归的方法前序遍历二叉树 

*/

void Preorder(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	cout<<root->value<<endl;	//节点数据处理操作

​	Preorder(root->left);	//处理完所有左子树

​	Preorder(root->right);	//处理完所有右子树

} 

或者：

class Solution {

private:

vector<int> tmpArr;

//不要定义在方法体中，否则为临时变量每次都初始化

public:

  vector<int> preorderTraversal(TreeNode* root) {     

​    if(nullptr != root)

​    {

​      tmpArr.push_back(root->val);

​      preorderTraversal(root->left);

​      preorderTraversal(root->right);

​    }

​    return tmpArr;

  }

};

#### *非递归*

​	思路：使用栈来做辅助数据，右儿子先进入，左儿子后进入。

1、 首先申请一个新的栈，记为stack

2、 然后将头结点head压入stack中

3、 每次从stack中弹出栈顶节点，记为cur，然后打印cur节点的值。如果cur右孩子不为空的话，将cur的右孩子先压入stack中。最后如果cur的左孩子不为空的话，将cur的左孩子压入stack中。

4、 不断重复步骤3，直到stack为空，全部过程结束。

举例：

先把头结点1压入栈中，然后打印节点1：

   

 

​	接着把节点1的右孩子3压入栈，然后左孩子2压入栈：

 

​	然后把节点2打印，将右孩子5à左孩子4压栈：

 

​	节点4没有孩子，则打印节点4à节点5：

 

 

​	节点5没有孩子，弹出节点3打印：

 

​	节点7à节点6入栈：

 

​	然后，节点7à6依次打印。

​	代码：

void PreOrder(TreeNode *r)

{

​	stack<TreeNode *> s;

​	s.push(r);		//把root节点先放入栈中

​	while(!s.empty())

​	{

​		r = s.top();	//逐一出栈（第一次进来是头结点出栈，后面就是左子树）

​		s.top();

​		if(r != NULL)

​		{

​			cout << r->val << " ";

​			s.push(r->right);

​			s.push(r->left);

​		}

​	}

}

### 中序遍历

​	中序遍历：遍历左子树à再访问根节点à再中序遍历右子树

#### *递归*

方式一：

public void inOrderRecur(Node head){

​	if(head == null){

​		return;

​	}

​	inOrderRecur(head.left);

​	System.out.print(head.value + " ");

​	inOrderRecur(head.right);

}

方式二：

/*

递归的方法中序遍历二叉树 

*/

void Inorder(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	Inorder(root->left);

​	cout<<root->value<<endl;

​	Inorder(root->right);

} 

#### *非递归*

​	思路：

1、 申请一个新的栈，记为stack，申请一个变量cur，初始时令cur等于头节点；

2、 先把cur节点压入栈中，对以cur节点为头的整棵子树来说，依次把整棵树的左边界压入栈中，即不断令cur=cur.left，然后重复步骤2；

3、 不断重复步骤2，直到发现cur为空，此时此stack中弹出一个节点，记为node。打印node的值，并让cur=node.right，然后继续重复步骤2。

4、 当stack为空并且cur为空时，整个过程结束。

举例：

cur节点1入栈，然后将cur=2，入栈：

 

​	cur=4（左孩子）入栈：

 

​	继续cur=左孩子，但是此时节点4左孩子为空，弹出节点4打印：

 

​	将cur=5，此时左孩子还是为空，继续弹栈，弹出节点2并打印：

 

​	将节点5入栈，继续cur=左孩子，此时为空，弹出节点5并打印：

 

​	cur=右孩子，继续为空，弹栈：

 

​	cur=3，节点3入栈：

 

​	节点3左孩子6入栈：

 

​	节点6左孩子为空，则弹栈：

 

​	节点6右孩子为空，继续弹栈节点3：

 

​	cur=右孩子节点7：

 

​	此时节点7入栈，没有左孩子和右孩子，弹栈。

代码：

void InOrder(TreeNode *r)

{

​	stack<TreeNode *> s;

​	while(!s.empty() || NULL!=r)

​	{

​		while(r!=NULL)

​		{

​			s.push(r);

​			r = r->left;

​		}

​		if(!s.empty())

​		{

​			r = s.top();

s.pop();

​			cout << r->val << " ";

​			r = r->right;

​		}

​	}

}

### 后序遍历

​	后序遍历：先中序遍历左子树à再中序遍历右子树à再访问根节点

#### *递归*

/*

递归的方法后序遍历二叉树 

*/

void Postorder(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	Postorder(root->left);

​	Postorder(root->right);

​	cout<<root->value<<endl;

}

如果返回数组：

class Solution {

private:

  vector<int> val;

public:

  vector<int> postorderTraversal(TreeNode* root) {

​    if (NULL == root)

​      return val;

​    postorderTraversal(root->left);

​    postorderTraversal(root->right);

​    val.push_back(root->val);

​    return val;

  }

};

 

/非递归的遍历二叉树/

 

/*

非递归的前序遍历 

*/ 

void Preorder_Nonrecursive(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	stack<BinTree*> s;

​	s.push(root);

​	while(!s.empty())

​	{

​		BinTree* temp = s.top();

​		cout<<temp->value<<" ";

​		s.pop();

​		if(temp->right)

​			s.push(temp->right);

​		if(temp->left)

​			s.push(temp->left);

​	}

}

 

 

/第二种方法/

 

void Preorder_Nonrecursive1(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	stack<BinTree*> s;

​	BinTree* cur = root;

​	while(cur != NULL || !s.empty())

​	{

​		while(cur != NULL)

​		{

​			cout<<cur->value<<" ";

​			s.push(cur);

​			cur = cur->left;

​		}

​		if(!s.empty())

​		{

​			cur = s.top();

​			s.pop();

​			cur = cur->right;

​		}

​	}

} 

 

/非递归中序遍历/

void Inorder_Nonre(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	BinTree* cur = root;

​	stack<BinTree*> s;

​	while(cur != NULL || !s.empty())

​	{

​		while(cur != NULL)

​		{

​			s.push(cur);

​			cur = cur->left;

​		}

​		if(!s.empty())

​		{

​			cur = s.top();

​			s.pop();

​			cout<<cur->value<<" ";

​			cur = cur->right;

​		}

​	}

} 

 

/*

第二种方法 

*/

void  Inorder_Nonre2(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	stack<BinTree*> st;

​	BinTree* p = root;

​	while(p!= NULL || !st.empty())

​	{

​		if(p != NULL)

​		{

​			st.push(p);

​			p = p->left;

​		}

​		else

​		{

​			p=st.top();

​			st.pop();

​			cout<<p->value<<endl;

​			p = p->right;

​		}

​	}

} 

 

/*

非递归的后序遍历 

*/

void Postorder_Nonre(BinTree* root)

{

​	stack<BinTree*> s;

​	BinTree* cur = root;

​	BinTree* pre = NULL;//指向前一个被访问的节点

​	while(cur != NULL || !s.empty())

​	{

​		while( cur != NULL) //一直向左走直到为空 

​		{

​			s.push(cur);

​			cur = cur->left;

​		}

​		cur = s.top();

​		//当前节点的右孩子如果为空或者已经被访问，则访问当前节点

​		if(cur->right == NULL || cur->right == pre)

​		{

​			cout<<cur->value<<" ";

​			pre = cur;

​			s.pop();

​			cur = NULL;

​		} 

​		else

​			cur = cur->right;//否则访问右孩子 

​	} 

} 

 

/*

第二种方法 

*/ 

void Postorder_Nonre2(BinTree* root)

{

​	//使用双栈法

​	stack<BinTree*> s1,s2;

​	BinTree* cur;//指向当前要检查的节点

​	s1.push(root);

​	//栈为空时结束

​	while(!s1.empty())

​	{

​		cur = s1.top();

​		s1.pop();

​		s2.push(cur);

​		if(cur->left)

​			s1.push(cur->left);

​		if(cur->right)

​			s1.push(cur->right);

​	} 

​	while(!s2.empty())

​	{

​		cout<<s2.top()->value<<" ";

​		s2.pop(); 

​	}

}

 

int main()

{

​	BinTree* root =NULL;

​	int array[]={10,6,14,4,8,12,16};

​	for(int i=0;i<sizeof(array)/sizeof(int);i++)

​		root = InsertNode(root,array[i]);

​	Inorder_Nonre2(root);

​	return 0;

}

#### *非递归*

方法一：使用两个栈实现

​	具体过程如下：

1、 申请一个栈，记为s1，然后将头结点压入s1中；

2、 从s1中弹出的节点记为cur，然后先把cur的左孩子压入s1中，然后把cur1的右孩子压入s1中；

3、 在整个过程中，每一个从s1中弹出的节点都放入第二个栈s2中；

4、 不断重复步骤2和步骤3，直到s1为空，过程停止；

5、 从s2中依次弹出节点并打印，打印的熟顺序就是后序遍历的顺序。

 

​	弹出节点1，入栈s2：

 

​	节点1左孩子2入栈，然后右孩子3入栈：

 

​	弹出节点3，入栈s2，然后左孩子6，右孩子7依次入栈s1：

 

​	节点7弹栈，入栈s2，没有孩子，则节点6弹栈，入栈s2：

 

​	节点2无孩子继续弹栈：

 

​	节点5à节点4依次弹栈，入栈s2：

 

方法二：使用一个栈实现。

 

 

​	思路：

节点会出现在栈顶2次

有左儿子则自己进栈，R= 右儿子

第一次出现，r=右儿子

第二次出现，访问结点自己

​	代码：

struct StackNode{

​	TreeNode *r;

​	bool isFirst;

}

 

void PostOrder(TreeNode *r)

{

​	stack<StackNode> s;

​	StackNode snode;

​	while(!s.empty() || NULL !=r)

​	{

​		while(NULL!=r)

​		{

​			snode.isFirst = true;

​			snode.r = r;

​			s.push)snode);

​			r = r->right;

​		}

​		if(!s.empty())

​		{

​			snode = s.top();

​			s.pop();

​			

​			if(snode.isFirst)

​			{

​				snode.isFirst = false;

​				s.push(snode);

​				r = snode.r->right;

​			}

​			else{

​				cout << snode.r->val << " ";

​				r = NULL;

​			}

​		}

​	}

}

### 层次/宽度优先遍历

​	二叉树层次遍历，又称为宽度优先搜索，按树的层次一次访问树的结点。层次遍历使用队列对遍历节点进行存储，先进入队列的节点，优先遍历拓展其左孩子与右孩子。

​	分析：*按层遍历/宽度优先使用队列（深度优先使用栈）*

 

 

​	代码：

 

​	注：该题与从上往下打印二叉数一样。

### 从上往下打印二叉树

​	题目要求：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印。

 

​	分析：

​	这个树的打印难点在于不是完全二叉树，无法确定什么时候换行，因此需要存储这样的两个变量，last用于存储当前打印行的最右侧节点，nlast（next last）存储下一行最右侧节点，当遍历到last节点表示当前行结束，此时只需要将last更新为下一行最右节点nlast即可：

 

​	这样问题就转化为了正确更新last和nlast变量，只需要将nlast跟踪记录树宽度优先遍历最先加入的节点即可（最先加入的必是最右侧的节点位置）。

​	这里使用的是宽度优先遍历，因此使用数据结构队列存储last和nlast，开始时令last=1，然后节点1放入队列q，从队列中弹出q并打印：

 

​	然后将1的孩子结点2、3依次放入队列中，放入节点2时令nlast=2，放入节点3时令nlast=3：

 

​	此时发现弹出的节点1与last相等（即遍历到最右侧节点），说明该换行了，此时令last=nlast：

 

​	将节点2弹出队列，并将节点2的孩子4加入队列，同时令nlast=4（nlast一定是最新的节点）：

 

​	将节点3从队列中弹出，并将节点3的孩子5加入队列，同时令nlast=5：

 

​	放入孩子结点6时，nlast=6：

 

​	此时发现弹出的节点3已经是last，说明需要换行，令last=nlast=6：

 

注：剑指offer P137

### 已知遍历序列求原始二叉树

​	通过先序和中序或者中序和后序我们可以还原出原始的二叉树，但是通过先序和后序是无法还原出原始的二叉树的。

​	即，只有通过先序和中序或通过中序和后序，我们才可以唯一的确定一个二叉树。

#### *先序+中序-**>**后序*

#### *中序+后序-**>**先序*

 

### 序列化

​	我们平常编码构造的二叉树是存储在内存中的，如果需要进行树结构的持久化需要执行序列化，即将二叉树转化为字符串存储。

​	二叉树的序列化和反序列化：

1、 二叉树à字符串（序列化）

2、 字符串à二叉树（反序列化）

序列化的方式：

1、 根据先序遍历序列化

2、 根据中序遍历序列化

3、 根据后序遍历序列化

4、 按层序列化

#### *序列化*

​	用一个特殊字符表示一个二叉树节点值的结束的意义。

先序遍历对二叉树进行序列化：

1、 假设序列化结果为str，初始化str为空字符串；

2、 先序遍历二叉树时如果遇到空节点，在str末尾加上“#！”；

3、 如果遇到不为空的节点，假设节点值为3，就在str的末尾加上“3！”。

 

 

​	如果不用特殊符号表示值的结束，则这两棵树的序列化结果为123###，说明不用特殊字符表示节点值结束的话，会产生歧义。

 

按层遍历的方式对二叉树进行序列化：

1、 用队列来进行二叉树的按层遍历，即宽度优先遍历；

2、 除了访问节点的顺序是按层遍历之外，对结果字符串的处理，与之前介绍的处理方式一样；

3、 反序列化过程同理。

#### *反序列化*

​	一颗二叉树通过先序遍历得到的结果，如何进行反序列化：

 

​	总结：

1、 选择用什么样的遍历方式序列化，就选择用什么样的方式序列化；

2、 一棵树序列化的结果是唯一的，唯一的结果生成的二叉树也是唯一的。

 

### 侧面观察二叉树

​	题目：给定一个二叉树，假设从该二叉树的右侧观察它，将观察到的节点按照从上到下的顺序输出。

 

​	注：Leetcode 199

​	分析：

​	从二叉树的右侧观察它，将观察到的节点按照从上到下的顺序输出，就是求层次遍历二叉树，每个层中的最后一个节点。

 

​	思考：层次遍历时，如何记录每一层中出现的最后一个节点？

​	层次遍历时，将节点与层数绑定为pair，压入队列时，将节点与层数同时压入队列，并记录每一层中出现的最后一个节点。

​	在层次遍历中，每一层中的最后一个节点最后遍历到，随时更新对每层的最后一个节点即可。

 

​	代码：

 

​	测试：

 

## 查找

### 查找二叉搜索树的最大值和最小值

### 二叉树第K大数

​	题目：二叉树中的第K大数

​	分析：

 

注：Leetcode230

### 二叉搜索树中查找元素

## 删除

### 二叉搜索树中的删除

#include <iostream>

#include <stack>

#include <deque>

#include <vector>

#include <queue>

using namespace std;

 

/*

二叉搜索树的基本操作 

*/

typedef struct Bin_tree BinTree;

struct Bin_tree

{

​    int value;

​    BinTree* right;

​    BinTree* left;

};

/*

 构造二叉查找树 

*/

BinTree* InsertNode(BinTree* root,int data)

{

​     BinTree* newnode = new BinTree;

​     newnode->value = data;

​     newnode->right = NULL;

​     newnode->left = NULL;

​     if(root == NULL)

​     {

​         root = newnode;

​         }

​     else

​     {

​       BinTree* parent = root;

​    //   BinTree* cur = NULL;

​       while(parent != NULL)

​       {

​           if(parent->value < data)

​           {

​            if(parent->right == NULL) 

​             break;

​            else

​             parent = parent->right;  

​           }

​           else

​           {

​             if(parent->left == NULL)

​              break;

​             else

​              parent = parent->left;

​           } 

​       }

​       if(parent->value < data)

​       parent->right = newnode;

​       else

​       parent->left = newnode;

​       }

​     return root;

}

 

 

/**

查找二叉搜索树的最大值 

*/ 

 

BinTree* Max(BinTree* root)

{

​	if(root == NULL)

​		return NULL;

​	BinTree* temp = root;

​	while(temp->left != NULL)

​	{

​		temp = temp->left;

​	}

​	return temp;

}

 

/*

查找二叉搜索树的最小值 

*/

BinTree* Min(BinTree* root)

{

​	if(root == NULL)

​		return NULL;

​	BinTree* temp = root;

​	while(temp->right != NULL)

​	{

​		temp = temp->right;

​	}

​	return temp;

}

 

/*

在二叉搜索树中查找元素 

*/

BinTree* Search(BinTree* root,BinTree*& parent,int value)

{

​	if(root == NULL )

​		return NULL;

​	BinTree* temp = root;

​	parent = NULL;

​	while(temp != NULL)

​	{

​		if(temp->value == value)

​			break;

​		else

​		{

​			parent = temp;

​			if(temp->value > value)

​				temp = temp->left;

​			else

​				temp = temp->right;

​		}

​	}

​	if(temp == NULL)

​	{

​		parent = NULL;

​		return NULL;

​	}

​	return temp;

} 

 

 

/*

删除二叉搜索树种的某个节点 

*/

void Delete(BinTree*& root,int value)

{

​	BinTree* delnode = NULL;

​	if(root == NULL)

​		return ;

​	BinTree* temp = root;

​	BinTree* parent = NULL;

​	//首先需要查找该元素是否存在

​	while(temp != NULL)

​	{

​		if(temp->value == value)

​			break;

​		else

​		{

​			parent = temp;

​			if(temp->value > value)

​				temp = temp->left;

​			else

​				temp = temp->right;

​		}

​	} 

​	//如果没有找到被删除的节点，那么直接返回

​	if(temp == NULL)

​		return ;

​	delnode = temp;

​	/*

​	删除的节点被找到，接下来进行删除的操作，分为三种情况，

​	第一种情况是待删除节点没有孩子，那么直接删除

​	第二种情况是待删除节点有一个孩子（有可能是左孩子也有可能是右孩子）

​	第三种情况是待删除节点有两个孩子 

​	*/ 

​	/*

​	第一种情况，直接删除此节点 

​	*/

​	if(delnode->right == NULL && delnode->left == NULL)

​	{

​		if(delnode == root)

​		{

​			root = NULL;

​		}

​		if(parent && parent->left == delnode)

​		{

​			parent->left = NULL;

​		}

​		if(parent && parent->right == delnode)

​		{

​			parent->right = NULL;

​		}

​		delete delnode;

​	}

​	//如果此节点有一个孩子

​	if(delnode->right != NULL && delnode->left == NULL)

​	{

​		if(parent != NULL)

​		{

​			if(parent->left == delnode)

​				parent->left = delnode->right;

​			else if(parent->right == delnode)

​				parent->right = delnode->right;

​		}

​		else

​		{

​			root = delnode->right;

​		}

​		delete delnode;

​	} 

​	if(delnode->left != NULL && delnode->right == NULL)

​	{

​		if(parent != NULL)

​		{

​			if(parent->left == delnode)

​				parent->left = delnode->left;

​			else if(parent->right == delnode)

​				parent->right = delnode->left;

​		}

​		else

​		{

​			root = delnode->left;

​		}

​		delete delnode;

​	}

​	//两个节点都不为空 找一个合适的值替代 

​	if(delnode->left != NULL && delnode->right != NULL)

​	{

​		temp = delnode->right;

​		parent = delnode;

​		while(temp->left != NULL)

​		{

​			parent = temp;

​			temp = temp->left;

​		}

​		delnode->value = temp->value;

​		parent->left = temp->right;

​		delete temp;

​	} 

} 

 

int main()

{

​	int array[]={30,22,45,15,24,40,50,10};

​	BinTree* root = NULL;

​	for(int i=0;i<sizeof(array)/sizeof(int);i++)

​		root = InsertNode(root,array[i]);

​	Delete(root,30);

​	return 0;

}

## 二叉树构造和转换

### 遍历序列构造BST

#include <iostream>

#include <vector>

using namespace std;

 

/*

由一个二叉搜索树的前序序列和中序序列构造树 

*/

typedef struct tree_node Tree;

struct tree_node

{

​	Tree* left;

​	Tree* right;

​	int value;

};

 

Tree* helper(vector<int>& pre,int pre_begin,int pre_end,vector<int>& inorder,int in_begin,int in_end)

{

​	Tree* root = NULL;

​	int mid;

​	int i;

​	if(pre_end - pre_begin <0)

​		return NULL;

​	else

​	{

​		for(i = in_begin;i<=in_end;i++)

​			if(inorder[i] == pre[pre_begin])

​				break;

​		if(i > in_end)

​			return NULL;

​		

​		//创建节点

​		root = new Tree;

​		root->value = pre[pre_begin];

​		root->left = helper(pre,pre_begin+1,pre_begin+1+i-in_begin,inorder,in_begin,i-1);

​		root->right = helper(pre,pre_begin+1+i-1-in_begin+1,pre_end,inorder,i+1,in_end);

​		return root; 

​	}

} 

 

Tree* createBinTree(vector<int>& pre,vector<int>& inorder)

{

​	if(pre.size() == 0 || inorder.size()== 0)

​		return NULL;

​	return helper(pre,0,pre.size()-1,inorder,0,inorder.size()-1);

}

 

 

/*

由中序和后序序列遍历构造二叉树 

*/

Tree* helpersecond(vector<int>& inorder,int in_begin,int in_end,vector<int>& post,int post_begin,int post_end)

{

​	Tree* root = NULL;

​	int mid;

​	int i;

​	if(in_begin > in_end)

​	{

​		return NULL;

​	}

​	else

​	{

​		for(i= in_begin;i<=in_end;i++)

​			if(inorder[i] == post[post_end])

​				break;

​		if(i > in_end)

​			return NULL;

​		root = new Tree;

​		root->value = post[post_end];

​		root->left = helpersecond(inorder,in_begin,i-1,post,post_begin,post_begin+i-1-in_begin);

​		root->right = helpersecond(inorder,i+1,in_end,post,post_begin+i-in_begin,post_end-1);

​		

​	}

​	return root;

}

 

Tree* createBinTree2(vector<int>& inorder,vector<int>& post)

{

​	if(inorder.size() == 0|| post.size()==0)

​		return NULL;

​	return helpersecond(inorder,0,inorder.size()-1,post,0,post.size()-1);

} 

 

/前序遍历/ 

void print_pre(Tree* tree)

{

​	if(tree != NULL)

​	{

​		cout<<tree->value<<" "<<endl;

​		print_pre(tree->left);

​		print_pre(tree->right);

​	}

}

 

/中序遍历/

void print_inorder(Tree* tree)

{

​	if(tree != NULL)

​	{

​		print_inorder(tree->left);

​		cout<<tree->value<<endl;

​		print_inorder(tree->right);

​	}

}

 

void print_post(Tree* root)

{

​	if(root != NULL)

​	{

​		print_post(root->left);

​		print_post(root->right);

​		cout<<root->value<<endl;

​	}

​	

}

 

 

int main()

{

​	int array1[]={4,2,1,3,7,6,5,8};

​	vector<int> preorder(array1,array1+sizeof(array1)/sizeof(int));

​	

​	int array[]={1,2,3,4,5,6,7,8};

​	vector<int> inorder(array,array+sizeof(array)/sizeof(int));

​	

​	int array2[]={1,3,2,5,6,8,7,4};

​	vector<int> postorder(array2,array2+sizeof(array2)/sizeof(int));

​	

​	Tree* root = createBinTree(preorder,inorder);

​	print_inorder(root);

​	cout<<"==========="<<endl;

​	

​	Tree* second = createBinTree2(inorder,postorder);

​	print_inorder(second);

​	

​	return 0; 

}

### 判断序列是否为BST的后续遍历

#include <iostream>

#include <vector>

using namespace std;

 

/*

判断一个序列是否为二叉搜索树的后序遍历序列

 

对于后序遍历，一定要明白最后一个元素是根节点，左子树都比根元素大，

右子树都比根元素小

然后递归检测左右子树 

*/

 

bool helper_verify(vector<int>& vec,int begin,int end)

{

​	int i,j;

​	if(end-begin <=1)

​		return true;

​	for(i=begin;i<end;i++)

​		if(vec[i] > vec[end])

​			break;

​	for(j=i;j<end;j++)

​		if(vec[j] < vec[end])

​			break;

​	if(j<end-1)

​		return false;

​	return helper_verify(vec,begin,i-1) && helper_verify(vec,i,end-1);

} 

 

bool verifyBST(vector<int>& vec)

{

​	if(vec.size() <=1)

​		return true;

​	return helper_verify(vec,0,vec.size()-1);

}

 

 

 

int main()

{

​	int array[]={1,3,2,5,6,8,7,4};

​	vector<int> vec(array,array+sizeof(array)/sizeof(int));

​	cout<<verifyBST(vec);

​	return 0; 

}

### 有序数组转为BST

#include <iostream>

#include <vector>

using namespace std;

/*

将一个有序数组搞笑地插入到二叉搜索树中 

*/

typedef struct Bin_tree BinTree;

struct Bin_tree

{

​	int value;

​	BinTree* right;

​	BinTree* left;

};

 

/将有序数组插入BST/

void InsertFromArray(BinTree& root,int array,int start,int end)

{

​	if(start >end)

​		return ;

​	//初始化一个节点 

​	root = new BinTree;

​	root->left = NULL;

​	root->right = NULL;

​	//找到有序数组的中间点作为根节点

​	int mid = start+(end-start)/2;

​	root->value = array[mid];

​	//然后递归调用创造左子树和右子树

​	InsertFromArray(root->left,array,start,mid-1);

​	//创建右子树

​	InsertFromArray(root->right,array,mid+1,end); 

} 

 

/*

递归中序遍历 

*/

void Inorder(BinTree* root)

{

​	if(root == NULL)

​		return;

​	Inorder(root->left);

​	cout<<root->value<<endl;

​	Inorder(root->right);

}

 

int main()

{

​	int array[]={1,2,3,4,5,6,7,8,9};

​	BinTree* root = NULL;

​	InsertFromArray(root,array,0,8);

​	Inorder(root);

​	return 0;

}

 

### 链表和二叉树的转化

​	题目：给定一个二叉树，将该二叉树就地（in-place）转换为单链表。单链表中节点顺序为二叉树前序遍历顺序。

 

​	注：Leetcode 114

​	分析：

​	方法一：

​	前序遍历二叉树，将节点指针push进入vector，顺序遍历vector中的节点，链接相邻两节点，形成单链表。

​	该方法不满足就地转换的条件。

 

​	方法二：

 

 

 

​	代码：

​	方法一：

 

​	方法二：

 

​	测试：

 

#include <iostream>

#include <vector>

#include <string>

using namespace std;

 

/*

链表转化为二叉树

二叉树转化为双向链表 

*/

 

using namespace std;

typedef struct list_node List;  

struct list_node  

{  

  struct list_node* next;  

  int value;  

};  

 

 

typedef struct Bin_tree BinTree;

struct Bin_tree

{

​    int value;

​    BinTree* right;

​    BinTree* left;

}; 

 

void print_list(List* list)  

{  

  List* tmp=list;  

  while(tmp != NULL)  

  {  

​    cout<<tmp->value<<endl;  

​    tmp = tmp->next;  

  }  

}  

 

/* 

初始化List  将从1~n的数字插入到链表中  

*/  

void Init_List(List& head,int array,int n)  

{  

  head = NULL;  

  List* tmp;  

  List* record;  

​    

  for(int i=1;i<=n;i++)  

  {  

​    tmp = new List;  

​    tmp->next = NULL;  

​    tmp->value = array[i-1];  

​    if(head == NULL)  

​    {  

​      head = tmp;  

​      record = head;  

​    }  

​    else  

​    {  

​      record->next = tmp;  

​      record = tmp;  

​    }  

  }  

}  

 

int Len_list(List* list)  

{  

  if(list == NULL)  

​    return 0;  

  else  

​    return Len_list(list->next)+1;  

}  

 

void Inorder(BinTree* root)

{

   if(root == NULL)

​    return ;

   Inorder(root->left);

   cout<<root->value<<endl;

   Inorder(root->right);

}

 

/*

将一个有序的单链表转化为二叉搜索树 

*/ 

List* FindMid(List& list,List& head,List*& tail)

{

​	List* fast = head;

​	List* slow = head;

​	while(fast != NULL && fast->next != tail)

​	{

​		slow = slow->next;

​		fast = fast->next;

​		if(fast != NULL &&fast->next != tail)

​			fast = fast->next;

​	} 

​	return slow;

}

 

BinTree* helper(List& root,List& head,List*& tail)

{

​	BinTree* node = NULL;

​	if(head == tail || head == NULL)

​		return node;

​	List* mid = FindMid(root,head,tail);

​	List* next = mid->next;

​	node = new BinTree;

​	node->value= mid->value;

​	node->left = helper(root,head,mid);

​	node->right = helper(root,next,tail);

​	return node;

} 

 

BinTree* ConvertBST(List*& list)

{

​	BinTree* root = NULL;

​	if(list == NULL)

​		return root;

​	List* head = list;

​	List* tail = NULL;

​	root = helper(list,head,tail);

​	return root;

} 

 

/*

将一个二叉树转化为双向链表 

*/

BinTree* head =NULL;

void helper(BinTree* root,BinTree*& pre)

{

​	if(root == NULL && root == NULL)

​		return ;

​		

​	helper(root->left,pre);

​	if(head == NULL)

​		head = root;

​	if(pre == NULL)

​		pre = root;

​	else

​	{

​		root->left = pre;

​		pre->right = root;

​		pre = root;

​	}

​	//cout<<root->value<<"  "<<endl;

​	helper(root->right,pre);

}

BinTree* SearchTreeConverstToList(BinTree* root)

{

​	BinTree* pre = NULL;

​	helper(root,pre);

​	return head;

}

 

void helper_second(BinTree* root,BinTree& head,BinTree& tail)

{

​	if(root==NULL || (root->left == NULL && root->right == NULL))

​	{

​		head = root;

​		tail = root;

​		return;

​	}

​	BinTree* left_head = NULL;

​	BinTree* left_tail = NULL;

​	BinTree* right_head = NULL;

​	BinTree* right_tail = NULL;

​	

​	helper_second(root->left,left_head,left_tail);

​	helper_second(root->right,right_head,right_tail);

 

​	if(left_head == NULL)

​		head = root;

​	else

​	{

​		head = left_head;

​		left_tail->right = root;

​		root->right = left_tail;

​	}		

​	if(right_head == NULL)

​		tail = root;

​	else

​	{

​		tail = right_tail;

​		root->right = right_head;

​		right_head->left = root;

​	}

}

/*

第二种方法 

*/

BinTree* ConverstToList(BinTree* root)

{

​	BinTree* head=NULL;

​	BinTree* tail = NULL;

​	helper_second(root,head,tail);

​	return head;

}

int main()

{

​	int array[]={1,2,3,4,5,6,7,8,9,10};

​	List* list;

​	Init_List(list,array,sizeof(array)/sizeof(int));

​	BinTree* root = ConvertBST(list);	

​	print_list(list);

​	Inorder(root);

​	return 0;

}

## 应用

### 二叉树中节点个数

### 二叉树的深度和宽度

### 二叉树中根到叶子的路径

注：Leetcode 257

### 求根节点到某节点路径

​	题目：

​	分析：

深度搜索：

1、 从根节点遍历（搜索）至该节点，找到该节点后就结束搜索；

2、 将遍历过程中遇到的节点按照顺序存储起来，这些节点即路径节点。

 

​	求根节点至某节点路径（栈存储路径）：

 

​	代码：

 

​	测试：

 

### 查找根到叶子的固定路径值

​	题目：给定一个二叉树与整数sum，找出所有从根节点到叶节点的路径，这些路径上的节点值累加和为sum。

 

​	注：Leetcode 113

​	分析：

​	深度搜索所有从根节点到叶节点的路径，检查各路径上所有节点的值的和是否为sum。

 

​	思考：

1、 使用何种数据结构存储遍历路径上的节点？

2、 在树的前序遍历时做什么？后序遍历时做什么？

3、 如何判断一个节点为叶节点？当遍历到叶节点时应该做什么？

算法思路：

1、 从根节点深度遍历二叉树，先序遍历时，将该节点值存储至path栈中（vector实现），使用path_value累加节点值；

2、 当遍历至叶节点时，检查path_value值是否为sum，若为sum，则将path push进入result结果中；

3、 在后续遍历时，将该节点值从path栈中弹出，path_value减去节点值。

 

 

 

 

 

​	代码：

 

 

测试：

 

 

#include <iostream>

#include <stack>

#include <vector>

#include <deque>

using namespace std;

 

/*

根到叶子路径之和为指定值 

*/

 

using namespace std; 

typedef struct Bin_tree BinTree;

struct Bin_tree

{

​    int value;

​    BinTree* right;

​    BinTree* left;

};

/*

 构造二叉查找树 

*/

BinTree* InsertNode(BinTree* root,int data)

{

​     BinTree* newnode = new BinTree;

​     newnode->value = data;

​     newnode->right = NULL;

​     newnode->left = NULL;

​     if(root == NULL)

​     {

​         root = newnode;

​     }

​     else

​     {

​       BinTree* parent = root;

​    //   BinTree* cur = NULL;

​       while(parent != NULL)

​       {

​           if(parent->value < data)

​           {

​            if(parent->right == NULL) 

​             break;

​            else

​             parent = parent->right;  

​           }

​           else

​           {

​             if(parent->left == NULL)

​              break;

​             else

​              parent = parent->left;

​           } 

​       }

​       if(parent->value < data)

​       parent->right = newnode;

​       else

​       parent->left = newnode;

​       }

​     return root;

}

/*

 递归 前序遍历二叉树 

*/ 

void Preorder(BinTree* root)

{

   if(root == NULL)

​    return ;

   cout<<root->value <<endl;

   Preorder(root->left);

   Preorder(root->right);

}

 

/*

 递归 中序遍历二叉树 

*/

void Inorder(BinTree* root)

{

   if(root == NULL)

​    return ;

   Inorder(root->left);

   cout<<root->value<<endl;

   Inorder(root->right);

}

 

//根到叶子路径和为某一个值 

void helper(BinTree* root,int key,int cur,vector<int>& vec)

{

​	if(root == NULL)

​		return ;

​	cur+=root->value;

​	vec.push_back(root->value);

​	if(root->left == NULL && root->right == NULL && cur == key)

​	{

​		int i;

​		for(i=0;i<vec.size();i++)

​			cout<<vec[i]<<"  ";

​		cout<<endl;	

​		

​	}	

​	if(root->left !=NULL)

​	{

​		helper(root->left,key,cur,vec);

​		vec.pop_back();

​	}

​		

​	if(root->right !=NULL)

​	{

​		helper(root->right,key,cur,vec);

​		vec.pop_back();

​	}

}

 

void PathSum(BinTree* root,int key)

{

​	int cur=0;

​	if(root== NULL)

​		return ;

​	vector<int> vec;

​	helper(root,key,cur,vec);

​	

}

//第二种方法

bool PathSum_second(BinTree* root,int value)

{

​	if(root == NULL)

​		return 0;

​	if(root->left == NULL && root->right == NULL &&root->value == value)

​		return 1;

​	return PathSum_second(root->left,value-root->value)||PathSum_second(root->right,value-root->value);

} 

 

/*

从根到叶子所有路径中，路径和最大的值 

*/

void helper_sum(BinTree* root,vector<int>& path,int& maxsum)

{

​	if(root == NULL)

​		return;

​	path.push_back(root->value);

​	if(root->left == NULL && root->right == NULL)

​	{

​		int tmp =0;

​		for(int i=0;i<path.size();i++)

​		{

​			tmp += path[i];

​			cout<<path[i]<<" ";

​		}

​		cout<<endl;

​		maxsum = max(tmp,maxsum);

​	}

​	helper_sum(root->left,path,maxsum);

​	helper_sum(root->right,path,maxsum);

​	path.pop_back();

}

 

int MaxPathToLeaf(BinTree* root)

{

​	if(root ==NULL)

​		return 0;

​	vector<int> path;

​	int maxsum =0;

​	helper_sum(root,path,maxsum);

​	return maxsum;

}

 

 

int main()

{

​	BinTree* root = NULL;

​	BinTree* second = NULL;

​	int array[]={10,6,14,3,16,5,8};

​	int i;

​	for(i=0;i<sizeof(array)/sizeof(int);i++)

​		root = InsertNode(root,array[i]);

​	PathSum(root,24);

​	return 0;

}

​	

### 二叉树中和为某一值的路径

​	题目要求：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶子结点所经过的结点形成一条路径。二叉树结点的定义如下：

​	struct BinaryTreeNode

​	{

​		int  m_nValue;

​		BinaryTreeNode  m_pLeft;

BinaryTreeNode  m_pRight;

};

​	注：剑指offer P143

### 求节点的最大距离

#include <iostream>

#include <stack>

using namespace std;

 

/*

求二叉树中节点的最大距离 

*/

typedef struct Bin_tree BinTree;

struct Bin_tree

{

​    int value;

​    BinTree* right;

​    BinTree* left;

};

/*

 构造二叉查找树 

*/

BinTree* InsertNode(BinTree* root,int data)

{

​     BinTree* newnode = new BinTree;

​     newnode->value = data;

​     newnode->right = NULL;

​     newnode->left = NULL;

​     if(root == NULL)

​     {

​         root = newnode;

​         }

​     else

​     {

​       BinTree* parent = root;

​    //   BinTree* cur = NULL;

​       while(parent != NULL)

​       {

​           if(parent->value < data)

​           {

​            if(parent->right == NULL) 

​             break;

​            else

​             parent = parent->right;  

​           }

​           else

​           {

​             if(parent->left == NULL)

​              break;

​             else

​              parent = parent->left;

​           } 

​       }

​       if(parent->value < data)

​       parent->right = newnode;

​       else

​       parent->left = newnode;

​       }

​     return root;

}

/*

 递归 前序遍历二叉树 

*/ 

void Preorder(BinTree* root)

{

   if(root == NULL)

​    return ;

   cout<<root->value <<endl;

   Preorder(root->left);

   Preorder(root->right);

}

 

/*

 递归 中序遍历二叉树 

*/

void Inorder(BinTree* root)

{

   if(root == NULL)

​    return ;

   Inorder(root->left);

   cout<<root->value<<endl;

   Inorder(root->right);

}

 

/*

二叉树中任意两个节点的最远距离，这里的距离就是边的个数 

*/

/*

分情况讨论：

最远的两个节点一个在右子树，一个在左子树，那么就是左子树种最远节点

到当前节点的距离加上右子树种最远节点到当前节点的距离，这种情况最远

距离跨越了根节点。

第二种情况就是最远距离的两个节点都在右子树

第三种情况就是最远距离的两个节点都早左子树 

*/ 

 

/*

distance是以root为根的树的深度

返回值就是以root为根的树，任意两点的最远距离 

*/

int Distance(BinTree* root,int& depth)

{

​	if(root == NULL)

​	{

​		depth = 0;

​		return 0;

​	} 

​	int left,right;

​	int left_dis = Distance(root->left,left);

​	int right_dis = Distance(root->right,right);

​	depth = (left > right ? left: right)+1;

​	

​	return max(left_dis,max(right_dis,left+right));

} 

 

/*

如果二叉树为空，深度都为0

如果不为空，最大距离要么是左子树的最大距离，要么是右子树

的最大距离，要么是左子树到根节点的最大距离+右子树节点中到根节点

最大距离 

*/

 

int MaxDepth(BinTree* root)

{

​	int depth =0;

​	if(root != NULL)

​	{

​		int left_depth = MaxDepth(root->left);

​		int right_depth = MaxDepth(root->right);

​		depth = (left_depth > right_depth? left_depth: right_depth);

​		depth++;

​	}

​	return depth;

} 

 

int MaxDistance(BinTree* root)

{

​	int maxdis = 0;

​	if(root != NULL)

​	{

​		maxdis = MaxDepth(root->right) + MaxDepth(root->left);

​		int left_dis = MaxDistance(root->left);

​		int right_dis = MaxDistance(root->right);

​		int temp = left_dis > right_dis? left_dis : right_dis;

​		maxdis = temp > maxdis ? temp:maxdis;

​	}

​	return maxdis;

} 

 

 

int GetMaxDistance(BinTree* root,int& maxLeft,int& maxRight)

{

​	//maxLeft，左子树中的节点距离当前根节点的最远距离

​	//maxRight 右子树中的节点距离当前根节点的最远距离

​	if(root == NULL)

​	{

​		maxLeft  =0;

​		maxRight = 0;

​		return 0;

​	} 

​	int maxLL,maxLR,maxRL,maxRR;

​	int maxDisLeft,maxDisRight;

​	if(root->left != NULL)

​	{

​		maxDisLeft = GetMaxDistance(root->left,maxLL,maxLR);

​		maxLeft = max(maxLL,maxLR)+1;

​	} 

​	else

​	{

​		maxDisLeft = 0;

​		maxLeft = 0;

​	}

​	if(root->right != NULL)

​	{

​		maxDisRight = GetMaxDistance(root->right,maxRL,maxRR);

​		maxRight = max(maxRL,maxRR)+1;

​	}

​	else

​	{

​		maxDisRight = 0;

​		maxRight = 0;

​	}

​	return max(max(maxDisLeft,maxDisRight),maxLeft+maxRight);

}

 

int main()

{

​	

​	BinTree* root = NULL;

​	int array[]={10,6,14,4,8,12,16,5};

​	int i;

​	for(i=0;i<sizeof(array)/sizeof(int);i++)

​		root = InsertNode(root,array[i]);

​	int dis=0;

​	cout<<Distance(root,dis)<<endl;

​	int right = 0;

​	int left = 0;

​	cout<<MaxDistance(root)<<endl;

​	cout<<GetMaxDistance(root,left,right)<<endl;

​	return 0;

}

 

### 判断两个二叉树是否相同

​	题目：判断两个二叉树是否相同

​	代码：

struct TreeNode{

​	int val;

​	TreeNode *left;

​	TreeNode *right;

​	TreeNode(int x) : val(x), left(NULL), right(NULL){}

};

 

class Solution{

​	public:

​		bool isSameTree(TreeNode *p, TreeNode *q){

​			if( NULL == p && NULL == q)	return true;

​			if( NULL != p && NULL != q && p->val == q->val){

​				return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);

​			}

​			return false;

​		}

};

​	注：Leetcode100（Leetcode100/101都是一个思想）

### 二叉树的镜像和相同性的判断

​	题目：判断1个数是否左右映射（Leetcode101）

​	分析：跟判断二叉树是否相同思路类似

​	代码：

struct TreeNode{

​	int val;

​	TreeNode *left;

​	TreeNode *right;

​	TreeNode(int x) : val(x), left(NULL), right(NULL){}

};

 

class Solution{

​	public:

​		bool JudgeSymmetricTree(TreeNode *p, TreeNode *q){

​			if( NULL == p && NULL == q)	return true;

​			if( NULL != p && NULL != q && p->val == q->val){

​				return JudgeSymmetricTree(p->left,q->left) && JudgeSymmetricTree(p->right,q->right);

​			}

​			return false;

​		}	

​		bool isSymmetricTree(TreeNode *root){

​			if( NULL == root )	return true;

​			return isSymmetricTree(root->left,root->right);

​		}

};

 

#include <iostream>

#include <stack>

#include <vector>

#include <deque>

#include <queue>

using namespace std;

 

/*

二叉树的基本操作 

*/

 

typedef struct Bin_tree BinTree;

struct Bin_tree

{

​    int value;

​    BinTree* right;

​    BinTree* left;

};

/*

 构造二叉查找树 

*/

BinTree* InsertNode(BinTree* root,int data)

{

​     BinTree* newnode = new BinTree;

​     newnode->value = data;

​     newnode->right = NULL;

​     newnode->left = NULL;

​     if(root == NULL)

​     {

​         root = newnode;

​         }

​     else

​     {

​       BinTree* parent = root;

​    //   BinTree* cur = NULL;

​       while(parent != NULL)

​       {

​           if(parent->value < data)

​           {

​            if(parent->right == NULL) 

​             break;

​            else

​             parent = parent->right;  

​           }

​           else

​           {

​             if(parent->left == NULL)

​              break;

​             else

​              parent = parent->left;

​           } 

​       }

​       if(parent->value < data)

​       parent->right = newnode;

​       else

​       parent->left = newnode;

​       }

​     return root;

}

 

/*

层次遍历二叉树 使用队列或者双端队列 

*/ 

 

void FloorVisit(BinTree* root)

{

​	if(root == NULL)

​		return ;

​	deque<BinTree*> dequ;

​	dequ.push_back(root);

​	BinTree* current = NULL;

​	//开始遍历

​	while(dequ.size())

​	{

​		current = dequ.front();

​		dequ.pop_front();

​		cout<<current->value<<endl;

​		if(current->left != NULL)

​			dequ.push_back(current->left);

​		if(current->right != NULL)

​			dequ.push_back(current->right); 

​	} 

}

 

/*

二叉树中节点的个数 

*/

int NumOfTree(BinTree* root)

{

​	if(root == NULL)

​		return 0;

​	return (NumOfTree(root->right)+NumOfTree(root->left)) +1;

} 

 

/*

二叉树的深度 

*/

 

int Depth(BinTree* root)

{

​	if(root == NULL)

​		return 0;

​	int left = Depth(root->left);

​	int right = Depth(root->right);

​	return (left > right ? left:right)+1;

}

 

/*

二叉树的宽度 （二叉树的宽度就是节点最多的那层中节点的个数） 

*/

void Width(BinTree* root,int& width)

{

​	if(root == NULL)

​		return;

​	deque< BinTree*> dequ;

​	dequ.push_back(root);

​	BinTree* current;

​	width =0;

​	int tempWidth= dequ.size();

​	//开始查找宽度

​	while(tempWidth)

​	{

​		if(tempWidth > width)

​			width = tempWidth;

​		while(tempWidth)

​		{

​			current = dequ.front();

​			dequ.pop_front();

​			if(current->left != NULL)

​				dequ.push_back(current->left);

​			if(current->right != NULL)

​				dequ.push_back(current->right);

​			tempWidth--;

​		}

​		tempWidth = dequ.size();

​	} 

}

 

/*

二叉树中跟到叶子节点的路径 

*/

void Routh(BinTree* root,vector<BinTree*>& vec)

{

​	if(root == NULL)

​		return ;

​	vec.push_back(root);

​	if(root->left == NULL && root->right == NULL)

​	{

​		vector<BinTree*>::iterator itr = vec.begin();

​		for(;itr!=vec.end();itr++)

​		{

​			cout<<(*itr)->value<<endl;

​		}

​		cout<<"-----"<<endl;

​	}

​	Routh(root->left,vec);

​	Routh(root->right,vec);

​	vec.pop_back();

}

 

/*

判断两棵二叉树是否结构相同 

*/

bool JudeSame(BinTree* first,BinTree* second)

{

​	if(first == NULL && second == NULL)

​		return true;

​	if((first == NULL && second!=NULL) || (first != NULL && second == NULL))

​		return false;

​	if(first->value != second->value)

​		return false;

​	return (JudeSame(first->left,second->left)&&(JudeSame(first->right,second->right)));

​	

}

 

/*

二叉树的镜像转换 

*/

void Reverse(BinTree* root)

{

​	if(root == NULL)

​		return;

​	BinTree* temp = NULL;

​	temp = root->right;

​	root->right = root->left;

​	root->left = temp;

​	//递归调用函数，使得左右子树都进行转换

​	Reverse(root->left);

​	Reverse(root->right); 

} 

 

int main()

{

​	int array[]={30,22,45,15,24,40,50,10};

​	BinTree* root = NULL;

​	for(int i=0;i<sizeof(array)/sizeof(int);i++)

​		root = InsertNode(root,array[i]);

​	//FloorVisit(root);	

​	vector<BinTree*> vec;

​	Routh(root,vec);

​	return 0;

}

### 求两节点的最近公共父节点

​	题目：已知二叉树，求二叉树给定的两个节点的最近公共祖先。

​	最近公共祖先：两节点v与w的最近公共祖先u，满足在树上最低（离根最远），且v,w两个节点都是u的子孙。

 

​	注：Leetcode 236

​	分析：

1、 两个节点的公共祖先一定在从根节点至这两个节点的路径上；

2、 由于求公共祖先中的最近公共祖先，那么即同时出现在这两条路径上的离根节点最远的节点（或离两个最近）；

3、 最终算法即：求p节点路径，q节点路径，两路径上最后一个相同的节点。

 

​	根据上述求根节点到某节点路径的算法：

1、 求出较短路径的长度n；

2、 同时遍历p节点的路径与q节点的路径，遍历n个节点，最后一个发现的相同节点，即最近公共祖先。

 

​	代码：

 

​	测试：

 

/*

输入二叉树的两个节点，输出这两个节点在树种最低的公共父节点 

*/

/*

遍历二叉树，找到一条从根节点开始到目标节点的路径，然后

在两条路径上查找共同的父节点 

*/ 

 

/*

得到从根到某一节点的路径 

*/

bool GetNodePath(BinTree* root,BinTree* node,vector<BinTree*>& path)

{

​	if(root == NULL)

​		return false;

​	if(root == node)

​		return true;

​	else if(GetNodePath(root->left,node,path))

​	{

​		path.push_back(root->left);

​		return true;

​	}

​	else if(GetNodePath(root->right,node,path))

​	{

​		path,push_back(root->right);

​		return true;

​	}

​	return false;

}

 

 

BinTree* GetLastNode(vector<BinTree>& path1,vector<BinTree>& path2)

{

​	vector<BinTree*>::iterator iter1 = path1.begin();

​	vector<BinTree*>::iterator iter2 = path2.begin();

​	BinTree* plast;

​	while(iter1 != path1.end() && iter2 != path2.end())

​	{

​		if(*iter1 == *iter2)

​			plast = *iter1;

​		else

​			break;

​		iter1++;

​		iter2++;

​	}

​	return plast;

} 

 

BinTree* GetParent(BinTree* root,BinTree* node1,BinTree* node2)

{

​	if(root == NULL || node1 == NULL || node2 == NULL)

​		return NULL;

​	vector<BinTree*> path1;

​	GetNodePath(root,node1,path1);

​	

​	vector<BinTree*> path1;

​	GetNodePath(root,node2,path2);

​	return GetLastNode(path1,path2); 

} 

 

/*

第二种方法

从头开始遍历，一旦发现有节点和两个节点中的一个相等，那么次节点就是目标

节点，要么公共父节点在左子树，要么在右子树。

如果发现两个节点一个在左子树，一个在右子树，那么当前节点就是公共父节点

如果发现都早右子树，那么公共父节点就在右子树，

如果发现都早左子树，那么公共父节点在右子树 

*/

bool FindNode(BinTree* root,BinTree* node)

{

​	if(root == NULL)

​		return false;

​	if(root == node)

​		return true;

​	return (FindNode(root->left,node) || FindNode(root->right,node));

}

 

BinTree* LCP(BinTree* root,BinTree* first,BinTree* second)

{

​	if(root == first || root== second)

​		return root;

​	bool isLeft = false;

​	isLeft = FindNode(root->left,first);

​	if(isLeft)

​	{

​		if(FindNode(root->left,second))

​			return LCP(root->left,first,second);

​		else

​			return root;

​	}

​	else

​	{

​		if(FindNode(root->right,second))

​			return LCP(root->right,first,second);

​		else

​			return root;

​	}

} 

 

/*

另一种简洁版

如果在左子树查找到了节点，left != NULL,那么看一下right是否为NULL

如果right != NULL ,那么说明左右两个子树中都查找到了公共父节点

那么说明最低的公共父节点就是当前的节点 

*/

 

BinTree* LCP2(BinTree8 root,BinTree* first,BinTree* second)

{

​	if(root == first || root== second)

​		return root;

​	if(root == NULL)

​		return NULL;

​	BinTree* left = LCP2(root->left,first,second);

​	BinTree* right = LCP2(root->right,first,second);

​	if(left == NULL)

​		return right;

​	else if(right == NULL)

​		return left;

​	else

​		return root;

}

### 字典树(**Trie)的基本操作**

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

 

/*

实现字典树的创建、插入、查询 

*/

 

#define MAX_CHILD 26

 

typedef struct Tree

{

​	int count;//用来标记该节点是否可以形成一个单词，count！=0 说明可以

​	struct Tree* child[MAX_CHILD];

​	

}Node,*Trie_node;

/*

child是表示每层有多少种类的数，如果是小字母，为26个 

*/ 

 

/*

创建Trie节点 

*/ 

Node* CreateTrie()

{

​	Node* node = (Node*)malloc(sizeof(Node));

​	memset(node,0,sizeof(Node));

​	return node;

} 

 

/*

Trie树插入节点 

*/

void Insert_node(Trie_node root,char* str)

{

​	if(root == NULL || *str == '\0')

​		return ;

​	Node* t = root;

​	while(*str != '\0')

​	{

​		if(t->child[*str-'a'] == NULL)

​		{

​			Node* tmp = CreateTrie();

​			t->child[*str-'a'] = tmp;

​		}

​		t = t->child[*str-'a'];

​		str++;

​	}

​	t->count++;

} 

 

/*

Trie中的查找 

*/

void search_str(Trie_node root,char* str)

{

​	if(NULL == root || *str == '\0')

​	{

​		printf("tire is empty\n");

​		return;

​	}

​	Node* t = root;

​	while(*str != '\0')

​	{

​		if(t->child[*str-'a'] != NULL)

​		{

​			t = t->child[*str-'a'];

​			str++;

​		}

​		else

​			break;

​	}

​	if(*str == '\0')

​	{

​		if(t->count == 0)

​			printf("该字符串不存在\n");

​		else

​			printf("该字符串存在\n"); 

​	}

​	else

​		printf("该字符串不存在\n"); 

} 

 

/*

释放整个字典树的空间 

*/

void del(Trie_node root)

{

​	int i;

​	for(i =0;i<MAX_CHILD;i++)

​	{

​		if(root->child[i] != NULL)

​			del(root->child[i]);

​	} 

​	free(root);

} 

 

 

int main()

{

​	int i,n;

​	char str[20];

​	printf("请输入要创建的trie树的大小：");

​	scanf("%d",&n);

​	Trie_node root = NULL;

​	root =CreateTrie();

​	if(root == NULL)

​		printf("创建Trie树失败\n");

​	for(i=0;i<n;i++)

​	{

​		scanf("%s",str);

​		Insert_node(root,str);

​	}

​	printf("trie树已经建立\n");

​	printf("请输入需要查询的字符串\n");

​	while(scanf("%s",str)!= NULL)

​	{

​		search_str(root,str);

​	}

​	return 0;

}

# 应用

树是数据库中数据结构一种重要形式

操作系统父子进程的关系本身就是一棵树

面向对象语言中类的继承关系本身就是一棵树

压缩软件——赫夫曼树

搜索——人机对战（不断做树的搜索，找到最优的路径）
